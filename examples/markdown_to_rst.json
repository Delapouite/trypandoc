{"text":"---\nauthor:\n- Albert Krewinkel\n- John MacFarlane\ndate: 'January 10, 2020'\ntitle: Pandoc Lua Filters\n---\n\n# Introduction\n\nPandoc has long supported filters, which allow the pandoc\nabstract syntax tree (AST) to be manipulated between the parsing\nand the writing phase. [Traditional pandoc\nfilters](https://pandoc.org/filters.html) accept a JSON\nrepresentation of the pandoc AST and produce an altered JSON\nrepresentation of the AST. They may be written in any\nprogramming language, and invoked from pandoc using the\n`--filter` option.\n\nAlthough traditional filters are very flexible, they have a\ncouple of disadvantages. First, there is some overhead in\nwriting JSON to stdout and reading it from stdin (twice, once on\neach side of the filter). Second, whether a filter will work\nwill depend on details of the user's environment. A filter may\nrequire an interpreter for a certain programming language to be\navailable, as well as a library for manipulating the pandoc AST\nin JSON form. One cannot simply provide a filter that can be\nused by anyone who has a certain version of the pandoc\nexecutable.\n\nStarting with version 2.0, pandoc makes it possible to write\nfilters in Lua without any external dependencies at all. A Lua\ninterpreter (version 5.3) and a Lua library for creating pandoc\nfilters is built into the pandoc executable. Pandoc data types\nare marshaled to Lua directly, avoiding the overhead of writing\nJSON to stdout and reading it from stdin.\n\nHere is an example of a Lua filter that converts strong emphasis\nto small caps:\n\n``` lua\nreturn {\n  {\n    Strong = function (elem)\n      return pandoc.SmallCaps(elem.c)\n    end,\n  }\n}\n```\n\nor equivalently,\n\n``` lua\nfunction Strong(elem)\n  return pandoc.SmallCaps(elem.c)\nend\n```\n\nThis says: walk the AST, and when you find a Strong element,\nreplace it with a SmallCaps element with the same content.\n\nTo run it, save it in a file, say `smallcaps.lua`, and invoke\npandoc with `--lua-filter=smallcaps.lua`.\n\nHere's a quick performance comparison, converting the pandoc\nmanual (MANUAL.txt) to HTML, with versions of the same JSON\nfilter written in compiled Haskell (`smallcaps`) and interpreted\nPython (`smallcaps.py`):\n\n  Command                                 Time\n  --------------------------------------- -------\n  `pandoc`                                1.01s\n  `pandoc --filter ./smallcaps`           1.36s\n  `pandoc --filter ./smallcaps.py`        1.40s\n  `pandoc --lua-filter ./smallcaps.lua`   1.03s\n\nAs you can see, the Lua filter avoids the substantial overhead\nassociated with marshaling to and from JSON over a pipe.\n\n# Lua filter structure\n\nLua filters are tables with element names as keys and values\nconsisting of functions acting on those elements.\n\nFilters are expected to be put into separate files and are\npassed via the `--lua-filter` command-line argument. For\nexample, if a filter is defined in a file `current-date.lua`,\nthen it would be applied like this:\n\n    pandoc --lua-filter=current-date.lua -f markdown MANUAL.txt\n\nThe `--lua-filter` option may be supplied multiple times. Pandoc\napplies all filters (including JSON filters specified via\n`--filter` and Lua filters specified via `--lua-filter`) in the\norder they appear on the command line.\n\nPandoc expects each Lua file to return a list of filters. The\nfilters in that list are called sequentially, each on the result\nof the previous filter. If there is no value returned by the\nfilter script, then pandoc will try to generate a single filter\nby collecting all top-level functions whose names correspond to\nthose of pandoc elements (e.g., `Str`, `Para`, `Meta`, or\n`Pandoc`). (That is why the two examples above are equivalent.)\n\nFor each filter, the document is traversed and each element\nsubjected to the filter. Elements for which the filter contains\nan entry (i.e.Â a function of the same name) are passed to Lua\nelement filtering function. In other words, filter entries will\nbe called for each corresponding element in the document,\ngetting the respective element as input.\n\nThe return value of a filter function must be one of the\nfollowing:\n\n-   nil: this means that the object should remain unchanged.\n-   a pandoc object: this must be of the same type as the input\n    and will replace the original object.\n-   a list of pandoc objects: these will replace the original\n    object; the list is merged with the neighbors of the\n    original objects (spliced into the list the original object\n    belongs to); returning an empty list deletes the object.\n\nThe function's output must result in an element of the same type\nas the input. This means a filter function acting on an inline\nelement must return either nil, an inline, or a list of inlines,\nand a function filtering a block element must return one of nil,\na block, or a list of block elements. Pandoc will throw an error\nif this condition is violated.\n\nIf there is no function matching the element's node type, then\nthe filtering system will look for a more general fallback\nfunction. Two fallback functions are supported, `Inline` and\n`Block`. Each matches elements of the respective type.\n\nElements without matching functions are left untouched.\n\nSee [module documentation](#module-pandoc) for a list of pandoc\nelements.\n\n## Filters on element sequences\n\nFor some filtering tasks, it is necessary to know the order\nin which elements occur in the document. It is not enough then to\ninspect a single element at a time.\n\nThere are two special function names, which can be used to define\nfilters on lists of blocks or lists of inlines.\n\n[`Inlines (inlines)`]{#inlines-filter}\n:   If present in a filter, this function will be called on all\n    lists of inline elements, like the content of a [Para]\n    (paragraph) block, or the description of an [Image]. The\n    `inlines` argument passed to the function will be a [List] of\n    [Inline] elements for each call.\n\n[`Blocks (blocks)`]{#blocks-filter}\n:   If present in a filter, this function will be called on all\n    lists of block elements, like the content of a [MetaBlocks]\n    meta element block, on each item of a list, and the main\n    content of the [Pandoc] document. The `blocks` argument\n    passed to the function will be a [List] of [Block] elements\n    for each call.\n\nThese filter functions are special in that the result must either\nbe nil, in which case the list is left unchanged, or must be a\nlist of the correct type, i.e., the same type as the input\nargument. Single elements are **not** allowed as return values,\nas a single element in this context usually hints at a bug.\n\nSee [\"Remove spaces before normal citations\"][Inlines filter\nexample] for an example.\n\nThis functionality has been added in pandoc 2.9.2.\n\n[Inlines filter example]: #remove-spaces-before-citations\n\n## Traversal order\n\nThe traversal order of filters can be selected by setting the key\n`traverse` to either `'topdown'` or `'typewise'`; the default is\n`'typewise'`.\n\nExample:\n\n``` lua\nlocal filter = {\n  traverse = 'topdown',\n  -- ... filter functions ...\n}\nreturn {filter}\n```\n\nSupport for this was added in pandoc 2.17; previous versions\nignore the `traverse` setting.\n\n### Typewise traversal\n\nElement filter functions within a filter set are called in a\nfixed order, skipping any which are not present:\n\n  1. functions for [*Inline* elements](#type-inline),\n  2. the [`Inlines`](#inlines-filter) filter function,\n  2. functions for [*Block* elements](#type-block) ,\n  2. the [`Blocks`](#inlines-filter) filter function,\n  3. the [`Meta`](#type-meta) filter function, and last\n  4. the [`Pandoc`](#type-pandoc) filter function.\n\nIt is still possible to force a different order by explicitly\nreturning multiple filter sets. For example, if the filter for\n*Meta* is to be run before that for *Str*, one can write\n\n``` lua\n-- ... filter definitions ...\n\nreturn {\n  { Meta = Meta },  -- (1)\n  { Str = Str }     -- (2)\n}\n```\n\nFilter sets are applied in the order in which they are returned.\nAll functions in set (1) are thus run before those in (2),\ncausing the filter function for *Meta* to be run before the\nfiltering of *Str* elements is started.\n\n### Topdown traversal\n\nIt is sometimes more natural to traverse the document tree\ndepth-first from the root towards the leaves, and all in a single\nrun.\n\nFor example, a block list `[Plain [Str \"a\"], Para [Str\n\"b\"]]`{.haskell} will try the following filter functions, in\norder: `Blocks`, `Plain`, `Inlines`, `Str`, `Para`, `Inlines`,\n`Str`.\n\nTopdown traversals can be cut short by returning `false` as a\nsecond value from the filter function. No child-element of\nthe returned element is processed in that case.\n\nFor example, to exclude the contents of a footnote from being\nprocessed, one might write\n\n``` lua\ntraverse = 'topdown'\nfunction Note (n)\n  return n, false\nend\n```\n\n","to":"rst","from":"markdown","standalone":true,"embed-resources":false,"citeproc":false,"html-math-method":"plain","wrap":"auto","highlight-style":"pygments","files":{},"template":null}